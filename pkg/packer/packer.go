package packer

import (
	"archive/zip"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"ops-system/pkg/protocol"
)

// GenerateTemplate 在指定目录生成 service.json 模板
func GenerateTemplate(targetDir string) error {
	// 确保目录存在
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		return err
	}

	manifestPath := filepath.Join(targetDir, "service.json")
	if _, err := os.Stat(manifestPath); err == nil {
		return fmt.Errorf("service.json already exists in %s", targetDir)
	}

	// 【修改】适配最新的 ServiceManifest 结构
	template := protocol.ServiceManifest{
		Name:        "demo-service",
		Version:     "1.0.0",
		Description: "Auto generated by pack-tool",
		OS:          "linux",

		// 启动
		Entrypoint: "bin/app",
		Args:       []string{"-c", "config.yaml"},
		Env: map[string]string{
			"GIN_MODE": "release",
		},

		// 停止
		StopEntrypoint: "",
		StopArgs:       []string{},

		// 【新增】健康检查默认值
		ReadinessType:    "tcp",
		ReadinessTarget:  ":8080",
		ReadinessTimeout: 30,

		// 【新增】日志映射
		LogPaths: map[string]string{
			"Access Log": "logs/access.log",
			"Error Log":  "logs/error.log",
		},

		// 默认 false
		IsExternal: false,
	}

	file, err := os.Create(manifestPath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(template)
}

// Pack 校验并打包 (保持不变)
func Pack(sourceDir string, outputZip string) error {
	sourceDir = filepath.Clean(sourceDir)

	// 1. 校验 service.json
	manifestPath := filepath.Join(sourceDir, "service.json")
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("service.json not found in %s. Please run 'init' first", sourceDir)
	}

	var m protocol.ServiceManifest
	if err := json.Unmarshal(data, &m); err != nil {
		return fmt.Errorf("invalid service.json format: %v", err)
	}

	// 2. 校验关键字段
	if m.Name == "" || m.Version == "" || m.Entrypoint == "" {
		return fmt.Errorf("service.json missing required fields (name, version, entrypoint)")
	}

	// 3. 校验 Entrypoint 文件是否存在
	if !filepath.IsAbs(m.Entrypoint) {
		entryFullPath := filepath.Join(sourceDir, m.Entrypoint)
		if _, err := os.Stat(entryFullPath); err != nil {
			return fmt.Errorf("entrypoint file not found: %s", m.Entrypoint)
		}
	}

	// 4. 创建 ZIP 文件
	if err := os.MkdirAll(filepath.Dir(outputZip), 0755); err != nil {
		return err
	}

	zipFile, err := os.Create(outputZip)
	if err != nil {
		return err
	}
	defer zipFile.Close()

	w := zip.NewWriter(zipFile)
	defer w.Close()

	// 5. 遍历目录打包
	return filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, _ := filepath.Rel(sourceDir, path)
		if err != nil {
			return err
		}

		if relPath == "." || path == outputZip {
			return nil
		}

		// Windows 路径分隔符转为 /
		zipPath := filepath.ToSlash(relPath)

		if info.IsDir() {
			return nil
		}

		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}
		header.Name = zipPath
		header.Method = zip.Deflate

		writer, err := w.CreateHeader(header)
		if err != nil {
			return err
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()

		_, err = io.Copy(writer, file)
		return err
	})
}
