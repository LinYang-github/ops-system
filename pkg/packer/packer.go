package packer

import (
	"archive/zip"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"ops-system/pkg/protocol"
)

// GenerateTemplate 在指定目录生成 service.json 模板
func GenerateTemplate(targetDir string) error {
	// 确保目录存在
	if err := os.MkdirAll(targetDir, 0755); err != nil {
		return err
	}

	manifestPath := filepath.Join(targetDir, "service.json")
	if _, err := os.Stat(manifestPath); err == nil {
		return fmt.Errorf("service.json already exists in %s", targetDir)
	}

	// 默认模板
	template := protocol.ServiceManifest{
		Name:        "demo-service",
		Version:     "1.0.0",
		Description: "Auto generated by pack-tool",
		OS:          "windows", // 或 linux
		Entrypoint:  "bin/app.exe",
		Args:        []string{"-c", "config.yaml"},
		Env: map[string]string{
			"GIN_MODE": "release",
		},
		StopEntrypoint: "",
		StopArgs:       []string{},
	}

	file, err := os.Create(manifestPath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(template)
}

// Pack 校验并打包
func Pack(sourceDir string, outputZip string) error {
	sourceDir = filepath.Clean(sourceDir)

	// 1. 校验 service.json
	manifestPath := filepath.Join(sourceDir, "service.json")
	data, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("service.json not found in %s. Please run 'init' first", sourceDir)
	}

	var m protocol.ServiceManifest
	if err := json.Unmarshal(data, &m); err != nil {
		return fmt.Errorf("invalid service.json format: %v", err)
	}

	// 2. 校验关键字段
	if m.Name == "" || m.Version == "" || m.Entrypoint == "" {
		return fmt.Errorf("service.json missing required fields (name, version, entrypoint)")
	}

	// 3. 校验 Entrypoint 文件是否存在
	// 注意：Entrypoint 可能是相对路径，也可能是绝对路径(纳管模式)。
	// 对于打包模式，通常要求是包内的相对路径。
	if !filepath.IsAbs(m.Entrypoint) {
		entryFullPath := filepath.Join(sourceDir, m.Entrypoint)
		if _, err := os.Stat(entryFullPath); err != nil {
			return fmt.Errorf("entrypoint file not found: %s", m.Entrypoint)
		}
	}

	// 4. 创建 ZIP 文件
	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputZip), 0755); err != nil {
		return err
	}

	zipFile, err := os.Create(outputZip)
	if err != nil {
		return err
	}
	defer zipFile.Close()

	w := zip.NewWriter(zipFile)
	defer w.Close()

	// 5. 遍历目录打包
	return filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 获取相对路径
		relPath, err := filepath.Rel(sourceDir, path)
		if err != nil {
			return err
		}

		// 忽略根目录本身
		if relPath == "." {
			return nil
		}

		// 忽略输出文件自己（如果输出文件就在源目录里）
		if path == outputZip {
			return nil
		}

		// Windows 路径分隔符转为 /
		zipPath := filepath.ToSlash(relPath)

		// 处理目录
		if info.IsDir() {
			// 某些 ZIP 解压软件需要显式的目录条目，但在 Go 中通常只需要文件
			// 如果需要保留空目录，可以写入一个以 / 结尾的条目
			return nil
		}

		// 写入文件头
		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}
		header.Name = zipPath
		header.Method = zip.Deflate // 压缩

		writer, err := w.CreateHeader(header)
		if err != nil {
			return err
		}

		// 写入文件内容
		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()

		_, err = io.Copy(writer, file)
		return err
	})
}
